{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AutoClean Pipeline","text":"<ul> <li> <p> Lightning Fast Processing</p> <p>Process EEG data with unprecedented speed using our optimized pipeline</p> <p> Quick Start</p> </li> <li> <p> Modular Architecture</p> <p>Build custom processing pipelines with plug-and-play components</p> <p> Pipeline Overview</p> </li> <li> <p> Extensive Step Functions</p> <p>Rich library of pre-built processing steps for common EEG operations</p> <p> Step Functions</p> </li> <li> <p> Flexible Configuration</p> <p>Easily customize processing parameters through YAML configuration files</p> <p> Configuration</p> </li> </ul>"},{"location":"#about-autoclean-pipeline","title":"About AutoClean Pipeline","text":"<p>AutoClean Pipeline is a powerful, modular framework for automated EEG data processing. Built on top of MNE and PyLossless, it provides researchers with a flexible and efficient way to process EEG data while maintaining the highest standards of data quality.</p> <pre><code>from autoclean import Pipeline\n\n# Initialize the pipeline\npipeline = Pipeline(\n    task=\"resting_eyes_open\",\n    data_path=\"path/to/data\"\n)\n\n# Run the pipeline\npipeline.run()\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> High Performance: Optimized for speed and efficiency</li> <li> Modular Design: Easy to extend and customize</li> <li> Rich Toolset: Comprehensive set of processing functions</li> <li> Quality Control: Built-in validation and reporting</li> <li> Reproducible: Version-controlled configurations</li> <li> BIDS Compatible: Standardized data organization</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Get up and running with AutoClean Pipeline in minutes:</p> InstallationConfigurationUsage <pre><code>pip install autoclean-pipeline\n</code></pre> <pre><code>task: resting_eyes_open\nparameters:\n  sampling_rate: 1000\n  line_noise: 60\n</code></pre> <pre><code>from autoclean import Pipeline\n\npipeline = Pipeline.from_config(\"config.yaml\")\npipeline.run()\n</code></pre>"},{"location":"#project-status","title":"Project Status","text":"<p>AutoClean Pipeline is actively maintained and used in production environments. We follow semantic versioning and maintain a detailed changelog of all updates.</p> <p> View Changelog</p>"},{"location":"plugin_system/","title":"AutoClean Unified Plugin System: User Guide","text":"<p>This guide explains how to use and extend the AutoClean plugin system to add support for new file formats and EEG montages without modifying core code.</p>"},{"location":"plugin_system/#overview","title":"Overview","text":"<p>The AutoClean plugin system uses a unified approach where each plugin handles: 1. File format import 2. Montage configuration  3. Event processing</p> <p>All in a single integrated unit, making it easier to handle specific format+montage combinations.</p>"},{"location":"plugin_system/#directory-structure","title":"Directory Structure","text":"<pre><code>src/autoclean/\n\u251c\u2500\u2500 step_functions/\n\u2502   \u2514\u2500\u2500 io.py                     # Core interfaces (don't modify)\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 formats/                  # Format registrations\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 additional_formats.py # Register new formats here\n\u2502   \u251c\u2500\u2500 eeg_plugins/              # Unified plugins for format+montage combinations\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 eeglab_mea30_plugin.py # Example plugin\n</code></pre>"},{"location":"plugin_system/#basic-usage","title":"Basic Usage","text":""},{"location":"plugin_system/#using-plugins-to-import-eeg-data","title":"Using Plugins to Import EEG Data","text":"<pre><code>from autoclean.step_functions.io import import_eeg\n\n# Configure the import\nautoclean_dict = {\n    \"run_id\": \"my_analysis_001\",\n    \"unprocessed_file\": \"/path/to/my/data.set\",  # Can be any supported format\n    \"eeg_system\": \"MEA30\",                       # Montage/system name\n    \"task\": \"oddball\",                           # Optional task type\n    # ...other configuration options...\n}\n\n# Import the data - plugins are automatically discovered and used\neeg_data = import_eeg(autoclean_dict)\n\n# eeg_data can be either Raw or Epochs depending on the plugin\n</code></pre>"},{"location":"plugin_system/#creating-a-custom-plugin","title":"Creating a Custom Plugin","text":""},{"location":"plugin_system/#step-1-register-your-file-format-if-needed","title":"Step 1: Register Your File Format (if needed)","text":"<p>If you're adding support for a new file format, register it first:</p> <pre><code># src/autoclean/plugins/formats/my_formats.py\nfrom autoclean.step_functions.io import register_format\n\n# Register your format - extension without dot, format ID in UPPERCASE\nregister_format('xyz', 'XYZ_FORMAT')\n</code></pre>"},{"location":"plugin_system/#step-2-create-your-plugin","title":"Step 2: Create Your Plugin","text":"<p>Create a file in <code>src/autoclean/plugins/eeg_plugins/</code> named descriptively to indicate the format+montage combination:</p> <pre><code># src/autoclean/plugins/eeg_plugins/xyz_custom64_plugin.py\nfrom autoclean.step_functions.io import BaseEEGPlugin\nfrom autoclean.utils.logging import message\n\nclass XYZCustom64Plugin(BaseEEGPlugin):\n    \"\"\"Plugin for XYZ files with Custom-64 montage.\"\"\"\n\n    VERSION = \"1.0.0\"  # Track your plugin version\n\n    @classmethod\n    def supports_format_montage(cls, format_id: str, montage_name: str) -&gt; bool:\n        \"\"\"Check which format+montage combinations this plugin supports.\"\"\"\n        return format_id == 'XYZ_FORMAT' and montage_name == 'CustomCap-64'\n\n    def import_and_configure(self, file_path, autoclean_dict, preload=True):\n        \"\"\"Import data and configure montage in one step.\"\"\"\n        message(\"info\", f\"Processing {file_path} with {autoclean_dict['eeg_system']}\")\n\n        try:\n            # 1. Import the data\n            # Your import code here...\n\n            # 2. Configure the montage\n            # Your montage configuration code here...\n\n            # 3. Process events if applicable\n            # Your event processing code here...\n\n            # Return either Raw or Epochs object\n            return raw  # or return epochs\n\n        except Exception as e:\n            raise RuntimeError(f\"Failed to process data: {str(e)}\")\n\n    def process_events(self, raw, autoclean_dict):\n        \"\"\"Process events after import (for Raw data).\"\"\"\n        # This is called automatically by import_eeg for Raw data\n        # Events code here...\n        return events, event_id, events_df\n\n    def get_metadata(self):\n        \"\"\"Return additional metadata about this plugin.\"\"\"\n        return {\n            \"plugin_version\": self.VERSION,\n            # Any other metadata you want to include\n        }\n</code></pre>"},{"location":"plugin_system/#step-3-use-your-plugin","title":"Step 3: Use Your Plugin","text":"<p>Your plugin will be automatically discovered and used when the appropriate format and montage are specified:</p> <pre><code>autoclean_dict = {\n    \"unprocessed_file\": \"my_data.xyz\",  # Your custom format\n    \"eeg_system\": \"CustomCap-64\",       # Your custom montage\n    # ...other options...\n}\n\n# Your plugin will be automatically selected\neeg_data = import_eeg(autoclean_dict)\n</code></pre>"},{"location":"plugin_system/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that adds support for XDF files with a BioSemi-64 montage:</p> <pre><code># src/autoclean/plugins/formats/bids_formats.py\nfrom autoclean.step_functions.io import register_format\nregister_format('xdf', 'XDF_FORMAT')\n\n# src/autoclean/plugins/eeg_plugins/xdf_biosemi64_plugin.py\nimport mne\nimport pyxdf\nfrom autoclean.step_functions.io import BaseEEGPlugin\nfrom autoclean.utils.logging import message\n\nclass XDFBioSemi64Plugin(BaseEEGPlugin):\n    \"\"\"Plugin for XDF files with BioSemi-64 montage.\"\"\"\n\n    VERSION = \"1.0.0\"\n\n    @classmethod\n    def supports_format_montage(cls, format_id: str, montage_name: str) -&gt; bool:\n        return format_id == 'XDF_FORMAT' and montage_name == 'biosemi64'\n\n    def import_and_configure(self, file_path, autoclean_dict, preload=True):\n        message(\"info\", f\"Processing XDF file with BioSemi-64 montage: {file_path}\")\n\n        try:\n            # Load XDF file using pyxdf\n            streams, header = pyxdf.load_xdf(file_path)\n\n            # Find EEG stream and extract data\n            eeg_stream = next((s for s in streams if s['info']['type'][0] == 'EEG'), None)\n            if not eeg_stream:\n                raise RuntimeError(\"No EEG stream found in XDF file\")\n\n            # Extract data, create MNE Raw object\n            data = eeg_stream['time_series'].T\n            sfreq = float(eeg_stream['info']['nominal_srate'][0])\n            ch_names = [f\"EEG{i+1}\" for i in range(data.shape[0])]\n\n            # Create Raw object\n            info = mne.create_info(ch_names=ch_names, sfreq=sfreq, ch_types='eeg')\n            raw = mne.io.RawArray(data, info)\n\n            # Apply BioSemi-64 montage\n            montage = mne.channels.make_standard_montage('biosemi64')\n            raw.set_montage(montage)\n\n            # Process events from marker stream if present\n            marker_stream = next((s for s in streams if s['info']['type'][0] == 'Markers'), None)\n            if marker_stream:\n                onsets = marker_stream['time_stamps'] - eeg_stream['time_stamps'][0]\n                descriptions = [str(m[0]) for m in marker_stream['time_series']]\n                raw.set_annotations(mne.Annotations(onsets, np.zeros_like(onsets), descriptions))\n\n            return raw\n\n        except Exception as e:\n            raise RuntimeError(f\"Failed to process XDF file: {str(e)}\")\n</code></pre>"},{"location":"plugin_system/#plugin-naming-conventions","title":"Plugin Naming Conventions","text":"<p>Use clear, descriptive names that indicate the format and montage combination:</p> <ul> <li><code>eeglab_mea30_plugin.py</code> - EEGLAB files with MEA30 montage</li> <li><code>egi_raw_gsn129_plugin.py</code> - EGI Raw files with GSN-HydroCel-129 montage</li> <li><code>brainvision_standard1020_plugin.py</code> - BrainVision files with standard 10-20 montage</li> </ul>"},{"location":"plugin_system/#returning-raw-vs-epochs","title":"Returning Raw vs. Epochs","text":"<p>Your plugin can return either a <code>mne.io.Raw</code> or <code>mne.Epochs</code> object:</p> <pre><code>def import_and_configure(self, file_path, autoclean_dict, preload=True):\n    # ... processing code ...\n\n    if autoclean_dict.get(\"return_epochs\", False):\n        # Create and return epochs\n        events, _ = mne.events_from_annotations(raw)\n        epochs = mne.Epochs(raw, events, tmin=-0.2, tmax=0.8, preload=True)\n        return epochs\n    else:\n        # Return continuous data\n        return raw\n</code></pre>"},{"location":"plugin_system/#advanced-plugin-features","title":"Advanced Plugin Features","text":""},{"location":"plugin_system/#task-specific-processing","title":"Task-Specific Processing","text":"<p>Handle different experimental paradigms:</p> <pre><code>def import_and_configure(self, file_path, autoclean_dict, preload=True):\n    # ... basic import code ...\n\n    # Apply task-specific processing\n    task = autoclean_dict.get(\"task\", None)\n    if task == \"oddball\":\n        # Apply oddball-specific processing\n        mapping = {\"1\": \"Standard\", \"2\": \"Target\"}\n        raw.annotations.rename(mapping)\n    elif task == \"mmn\":\n        # Apply MMN-specific processing\n        # ...\n\n    return raw\n</code></pre>"},{"location":"plugin_system/#multiple-formatmontage-support","title":"Multiple Format/Montage Support","text":"<p>A single plugin can support multiple combinations:</p> <pre><code>@classmethod\ndef supports_format_montage(cls, format_id: str, montage_name: str) -&gt; bool:\n    # Support multiple combinations\n    supported = [\n        ('EEGLAB_SET', 'GSN-HydroCel-64'),\n        ('EEGLAB_SET', 'GSN-HydroCel-128'),\n        ('EEGLAB_SET', 'GSN-HydroCel-256'),\n    ]\n    return (format_id, montage_name) in supported\n</code></pre>"},{"location":"plugin_system/#custom-configuration-options","title":"Custom Configuration Options","text":"<p>Pass additional configuration via <code>autoclean_dict</code>:</p> <pre><code>def import_and_configure(self, file_path, autoclean_dict, preload=True):\n    # Get custom options\n    reference = autoclean_dict.get(\"reference\", \"average\")\n    filter_settings = autoclean_dict.get(\"filter\", {\"l_freq\": 0.1, \"h_freq\": 40})\n\n    # ... import code ...\n\n    # Apply reference\n    if reference == \"average\":\n        raw.set_eeg_reference(\"average\")\n    elif reference == \"mastoids\":\n        raw.set_eeg_reference([\"M1\", \"M2\"])\n\n    # Apply filters\n    raw.filter(l_freq=filter_settings[\"l_freq\"], h_freq=filter_settings[\"h_freq\"])\n\n    return raw\n</code></pre>"},{"location":"plugin_system/#troubleshooting","title":"Troubleshooting","text":"<p>If your plugin isn't working:</p> <ol> <li>Plugin Discovery:</li> <li>Ensure your plugin is in the correct directory (<code>plugins/eeg_plugins/</code>)</li> <li> <p>Check that <code>__init__.py</code> files exist in all plugin directories</p> </li> <li> <p>Format Registration:</p> </li> <li>Verify your format is registered correctly in a file in <code>plugins/formats/</code></li> <li> <p>Check for typos in format IDs</p> </li> <li> <p>Debugging Tips:</p> </li> <li>Add <code>message(\"info\", \"Debug message\")</code> calls in your plugin</li> <li>Check if <code>supports_format_montage()</code> is returning <code>True</code> as expected</li> <li> <p>Test your plugin with a simple test script before integrating</p> </li> <li> <p>Common Issues:</p> </li> <li>Mismatch between registered format ID and what's checked in <code>supports_format_montage()</code></li> <li>Forgetting to handle exceptions properly</li> <li>Using incompatible MNE versions</li> </ol>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"user-guide/troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>macOS Installation Issues</li> <li>Missing libev dependency</li> <li>Missing pycairo dependency</li> </ul>"},{"location":"user-guide/troubleshooting/#macos-installation-issues","title":"macOS Installation Issues","text":""},{"location":"user-guide/troubleshooting/#missing-libev-dependency","title":"Missing libev dependency","text":"<p>Issue: When installing dependencies, you may encounter a build error with <code>bjoern</code> package related to missing <code>ev.h</code> file: <pre><code>fatal error: 'ev.h' file not found\n</code></pre></p> <p>Solution: Install the required <code>libev</code> library using Homebrew: <pre><code>brew install libev\n</code></pre></p> <p>After installing libev, retry your package installation command.</p>"},{"location":"user-guide/troubleshooting/#missing-pycairo-and-pkg-config-dependencies","title":"Missing pycairo and pkg-config dependencies","text":"<p>Issue: When installing dependencies, you may encounter a build error with <code>pycairo</code> package: <pre><code>Dependency lookup for cairo with method 'pkgconfig' failed:\nPkg-config for machine host machine not found\n</code></pre></p> <p>Solution: Install the required <code>py3cairo</code> package using Homebrew: <pre><code>brew install py3cairo pkg-config\n</code></pre></p> <p>After installing py3cairo, retry your package installation command.</p>"}]}